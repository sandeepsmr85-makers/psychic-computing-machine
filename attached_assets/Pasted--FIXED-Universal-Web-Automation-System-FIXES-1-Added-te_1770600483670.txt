/**

- FIXED Universal Web Automation System
- 
- FIXES:
- 1. ‚úÖ Added teach() method using observe()
- 1. ‚úÖ Added scrape() and scrapeMultiple() using extract()
- 1. ‚úÖ Fixed cache mechanism to use action objects
- 1. ‚úÖ Added all 4 Stagehand primitives
   */

import { Stagehand } from ‚Äú@browserbasehq/stagehand‚Äù;
import { z } from ‚Äúzod‚Äù;
import Anthropic from ‚Äú@anthropic-ai/sdk‚Äù;
import { storage } from ‚Äú../storage‚Äù;
import { type InsertCachedAction } from ‚Äú@shared/schema‚Äù;

interface WorkflowStep {
actionName: string;
params?: Record<string, any>;
}

interface AutomationResult {
success: boolean;
data?: any;
error?: string;
steps: string[];
cacheHits: number;
cacheMisses: number;
cost: number;
}

export class UniversalWebAutomation {
private stagehand!: Stagehand;
private anthropic: Anthropic;
private currentWebsite: string = ‚Äú‚Äù;
private runId: number;
private executionLog: string[] = [];
private cacheHits: number = 0;
private cacheMisses: number = 0;
private totalCost: number = 0;

constructor(runId: number) {
this.runId = runId;
this.anthropic = new Anthropic({
apiKey: process.env.ANTHROPIC_API_KEY || ‚Äú‚Äù,
});
}

private async log(message: string) {
console.log(`[Run ${this.runId}] ${message}`);
await storage.appendRunLog(this.runId, message);
}

async initialize(options: {
env?: ‚ÄúLOCAL‚Äù | ‚ÄúBROWSERBASE‚Äù;
headless?: boolean;
debugMode?: boolean;
} = {}) {
const { env = ‚ÄúLOCAL‚Äù, headless = true, debugMode = false } = options;

```
await this.log("üöÄ Initializing Universal Web Automation System...");

if (env === "BROWSERBASE") {
  if (!process.env.BROWSERBASE_API_KEY) {
    await this.log("‚ùå Missing BROWSERBASE_API_KEY");
    throw new Error("Missing BROWSERBASE_API_KEY");
  }
  this.stagehand = new Stagehand({
    env: "BROWSERBASE",
    apiKey: process.env.BROWSERBASE_API_KEY!,
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
    enableCaching: true,
    verbose: debugMode ? 2 : 0,
    modelName: "gpt-4o",
    modelClientOptions: {
      apiKey: process.env.OPENAI_API_KEY,
    },
    browserbaseSessionCreateParams: {
      proxies: true,
      browserSettings: {
        blockAds: true,
        solveCaptchas: true,
      },
    },
  });
} else {
  if (!process.env.OPENAI_API_KEY) {
    await this.log("‚ö†Ô∏è OPENAI_API_KEY not found. Stagehand requires an LLM provider.");
  }
  this.stagehand = new Stagehand({
    env: "LOCAL",
    enableCaching: true,
    verbose: debugMode ? 2 : 0,
    modelName: "gpt-4o",
    modelClientOptions: {
      apiKey: process.env.OPENAI_API_KEY,
    },
    localBrowserLaunchOptions: {
      headless,
      args: ["--no-sandbox", "--disable-setuid-sandbox"],
    },
  });
}

await this.stagehand.init();
await this.log("‚úÖ System initialized successfully!");
```

}

async goto(url: string) {
await this.log(`üåê Navigating to ${url}...`);
const page = this.stagehand.page;
await page.goto(url);
this.currentWebsite = new URL(url).hostname;
await this.log(`‚úÖ Loaded: ${this.currentWebsite}`);
}

async close() {
await this.log(‚Äúüëã Closing automation session‚Ä¶‚Äù);
await this.stagehand.close();
}

// ============================================================================
// CACHE MANAGEMENT
// ============================================================================

private getCacheKey(actionName: string, website: string): string {
return `${website}::${actionName}`;
}

// ============================================================================
// ‚úÖ FIX #1: TEACHING WITH OBSERVE
// ============================================================================

/**

- Teach the system a new action using observe()
- This is the CORRECT implementation using Stagehand‚Äôs observe primitive
  */
  async teach(
  name: string,
  instruction: string,
  type: ‚Äúact‚Äù | ‚Äúextract‚Äù = ‚Äúact‚Äù,
  schema?: z.ZodTypeAny
  ): Promise<{ success: boolean; action?: any; error?: string }> {
  const page = this.stagehand.page;
  const currentUrl = page.url();
  this.currentWebsite = new URL(currentUrl).hostname;

```
await this.log(`üìö Teaching action: "${name}"`);
await this.log(`   Instruction: "${instruction}"`);

try {
  let actionData: any;

  if (type === "act") {
    // ‚úÖ USE OBSERVE to get the action object (not act!)
    await this.log(`   Using observe() to learn the action...`);
    const observed = await this.stagehand.observe(instruction);
    
    if (!observed || observed.length === 0) {
      throw new Error("No actions observed");
    }

    actionData = observed[0];
    await this.log(`   ‚úÖ Learned action: ${JSON.stringify(actionData).substring(0, 100)}...`);
  } else if (type === "extract") {
    if (!schema) {
      throw new Error("Schema required for extract actions");
    }
    
    await this.log(`   Learning extraction pattern...`);
    // For extract, we execute once to validate but store the instruction + schema
    const result = await this.stagehand.extract(instruction, schema);
    actionData = {
      instruction,
      schema: schema.toString(),
      sampleResult: result,
    };
    await this.log(`   ‚úÖ Learned extraction pattern`);
  }

  // Save to database
  await storage.saveCachedAction({
    name,
    instruction,
    action: actionData,
    website: this.currentWebsite,
    type,
    schema: schema ? schema.toString() : undefined,
    timestamp: Date.now(),
  });

  await this.log(`   üíæ Cached action: "${name}" for ${this.currentWebsite}`);
  this.cacheMisses++;
  this.totalCost += 0.02;

  return { success: true, action: actionData };
} catch (error) {
  await this.log(`   ‚ùå Failed to teach action: ${error}`);
  return { success: false, error: String(error) };
}
```

}

/**

- Teach multiple actions at once
  */
  async teachBatch(
  actions: Array<{
  name: string;
  instruction: string;
  type?: ‚Äúact‚Äù | ‚Äúextract‚Äù;
  schema?: z.ZodTypeAny;
  }>
  ): Promise<Array<{ success: boolean; action?: any; error?: string }>> {
  await this.log(`üìö Teaching ${actions.length} actions...`);
  const results = [];

```
for (const { name, instruction, type = "act", schema } of actions) {
  const result = await this.teach(name, instruction, type, schema);
  results.push(result);
}

return results;
```

}

// ============================================================================
// ‚úÖ FIX #2: SCRAPING WITH EXTRACT
// ============================================================================

/**

- Scrape structured data from current page using extract()
  */
  async scrape<T>(instruction: string, schema: z.ZodType<T>): Promise<T> {
  await this.log(`üï∑Ô∏è Scraping: "${instruction}"`);
  this.cacheMisses++;
  this.totalCost += 0.03;

```
const result = await this.stagehand.extract(instruction, schema);
await this.log(`   ‚úÖ Scraped data successfully`);

return result as T;
```

}

/**

- Scrape multiple pages with pagination
  */
  async scrapeMultiple<T>(
  instruction: string,
  schema: z.ZodType<T>,
  options: {
  maxPages?: number;
  nextPageAction?: string;
  stopCondition?: (data: T[]) => boolean;
  } = {}
  ): Promise<T[]> {
  const { maxPages = 10, nextPageAction = ‚Äúclick next page button‚Äù } = options;
  const results: T[] = [];

```
await this.log(`üï∑Ô∏è Multi-page scraping (max ${maxPages} pages)...`);

for (let i = 0; i < maxPages; i++) {
  try {
    const data = await this.scrape(instruction, schema);
    results.push(data);
    await this.log(`   Page ${i + 1}: ‚úÖ Scraped`);

    if (options.stopCondition && options.stopCondition(results)) {
      await this.log(`   Stop condition met`);
      break;
    }

    // Try to go to next page
    if (i < maxPages - 1) {
      try {
        await this.execute(nextPageAction);
        await new Promise((resolve) => setTimeout(resolve, 2000));
      } catch (error) {
        await this.log(`   No more pages available`);
        break;
      }
    }
  } catch (error) {
    await this.log(`   Error on page ${i + 1}: ${error}`);
    break;
  }
}

await this.log(`   ‚úÖ Total pages scraped: ${results.length}`);
return results;
```

}

/**

- Scrape and save to run result
  */
  async scrapeAndSave<T>(
  instruction: string,
  schema: z.ZodType<T>,
  saveName?: string
  ): Promise<{ data: T; saved: boolean }> {
  const data = await this.scrape(instruction, schema);

```
try {
  // Save to run result
  const run = await storage.getRun(this.runId);
  const existingResult = (run?.result as any) || {};
  
  await storage.updateRun(this.runId, {
    result: {
      ...existingResult,
      scrapedData: {
        ...(existingResult.scrapedData || {}),
        [saveName || "data"]: data,
      },
    },
  });
  
  await this.log(`   üíæ Saved scraped data to run result`);
  return { data, saved: true };
} catch (error) {
  await this.log(`   ‚ö†Ô∏è Failed to save scraped data: ${error}`);
  return { data, saved: false };
}
```

}

// ============================================================================
// EXECUTING ACTIONS (FIXED)
// ============================================================================

/**

- Execute a single action (uses cached action objects from observe)
  */
  async execute(actionNameOrInstruction: string, params?: Record<string, any>): Promise<any> {
  const page = this.stagehand.page;
  const currentUrl = page.url();
  this.currentWebsite = new URL(currentUrl).hostname;

```
// Check DB cache
const cached = await storage.getCachedAction(actionNameOrInstruction, this.currentWebsite);

if (cached) {
  await this.log(`‚ö° Using cached action: "${actionNameOrInstruction}"`);
  this.cacheHits++;

  try {
    let instruction = cached.instruction;
    if (params) {
      Object.entries(params).forEach(([key, value]) => {
        instruction = instruction.replace(`{${key}}`, String(value));
      });
    }

    if (cached.type === "act") {
      // ‚úÖ Use the cached action object from observe()
      await this.stagehand.act(cached.action as any);
      await this.log(`   ‚úÖ Executed: ${actionNameOrInstruction}`);
      this.executionLog.push(`Executed: ${actionNameOrInstruction}`);
      return { success: true };
    } else if (cached.type === "extract") {
      // For extract, we need to re-run with the schema
      await this.log(`   Running extraction: ${actionNameOrInstruction}`);
      
      // Try to reconstruct schema (simplified - in production use better method)
      const result = await this.stagehand.extract(instruction, z.any());
      this.executionLog.push(`Extracted: ${actionNameOrInstruction}`);
      return result;
    }
  } catch (error) {
    await this.log(`   ‚ö†Ô∏è Cached action failed, re-learning...`);
    // Re-teach the action
    await this.teach(actionNameOrInstruction, cached.instruction, cached.type as any);
    return this.execute(actionNameOrInstruction, params);
  }
} else {
  await this.log(`ü§ñ Learning new action: "${actionNameOrInstruction}"`);
  this.cacheMisses++;
  this.totalCost += 0.02;

  let instruction = actionNameOrInstruction;
  if (params) {
    Object.entries(params).forEach(([key, value]) => {
      instruction = instruction.replace(`{${key}}`, String(value));
    });
  }

  const result = await this.stagehand.act(instruction);
  await this.log(`   ‚úÖ Executed: ${actionNameOrInstruction}`);
  this.executionLog.push(`Executed: ${actionNameOrInstruction}`);

  return result;
}
```

}

/**

- Execute a workflow (multiple actions in sequence)
  */
  async executeWorkflow(steps: WorkflowStep[]): Promise<AutomationResult> {
  await this.log(`üé¨ Executing workflow with ${steps.length} steps...`);
  this.executionLog = [];
  this.cacheHits = 0;
  this.cacheMisses = 0;
  this.totalCost = 0;

```
const results: any[] = [];

try {
  for (const step of steps) {
    const result = await this.execute(step.actionName, step.params);
    results.push(result);
  }

  return {
    success: true,
    data: results,
    steps: this.executionLog,
    cacheHits: this.cacheHits,
    cacheMisses: this.cacheMisses,
    cost: this.totalCost,
  };
} catch (error) {
  return {
    success: false,
    error: String(error),
    steps: this.executionLog,
    cacheHits: this.cacheHits,
    cacheMisses: this.cacheMisses,
    cost: this.totalCost,
  };
}
```

}

// ============================================================================
// NATURAL LANGUAGE PROMPT EXECUTION
// ============================================================================

/**

- Execute complex automation from natural language prompt
  */
  async prompt(instruction: string): Promise<AutomationResult> {
  await this.log(`üí¨ Processing prompt: "${instruction}"`);

```
try {
  const steps = await this.parseInstructionToSteps(instruction);
  await this.log(`   Parsed into ${steps.length} steps`);
  return this.executeWorkflow(steps);
} catch (e) {
  await this.log(`‚ùå Error parsing prompt: ${e}`);
  throw e;
}
```

}

/**

- Parse natural language into workflow steps using Claude
  */
  private async parseInstructionToSteps(instruction: string): Promise<WorkflowStep[]> {
  const page = this.stagehand.page;
  const currentUrl = page.url();
  this.currentWebsite = new URL(currentUrl).hostname;

```
const availableActions = await storage.listCachedActions(this.currentWebsite);

const prompt = `Parse this automation instruction into executable steps.
```

Website: ${this.currentWebsite}
Current URL: ${currentUrl}

Available cached actions:
${availableActions.map((a) => `- ${a.name}: ${a.instruction}`).join(‚Äù\n‚Äù) || ‚ÄúNone‚Äù}

User instruction: ‚Äú${instruction}‚Äù

Return a JSON array of steps. Each step should either:

1. Use a cached action by name if available
1. Provide a new instruction if no cached action fits

Format:
[
{ ‚ÄúactionName‚Äù: ‚Äúcached_action_name‚Äù, ‚Äúparams‚Äù: { ‚Äúkey‚Äù: ‚Äúvalue‚Äù } },
{ ‚ÄúactionName‚Äù: ‚Äúnew instruction here‚Äù, ‚Äúparams‚Äù: {} }
]

Return ONLY the JSON array, no other text.`;

```
const response = await this.anthropic.messages.create({
  model: "claude-sonnet-4-20250514",
  max_tokens: 2000,
  messages: [{ role: "user", content: prompt }],
});

const content = response.content[0];
if (content.type === "text") {
  const jsonMatch = content.text.match(/\[[\s\S]*\]/);
  if (jsonMatch) {
    return JSON.parse(jsonMatch[0]);
  }
}

throw new Error("Failed to parse instruction");
```

}

// ============================================================================
// UTILITY METHODS
// ============================================================================

/**

- Get current page screenshot
  */
  async screenshot(): Promise<Buffer> {
  const page = this.stagehand.page;
  const screenshot = await page.screenshot();
  await this.log(`üì∏ Screenshot captured`);
  return screenshot;
  }

/**

- Wait for navigation/page load
  */
  async waitForNavigation() {
  const page = this.stagehand.page;
  await page.waitForLoadState(‚Äúnetworkidle‚Äù);
  await this.log(`‚è≥ Page loaded`);
  }

/**

- Get execution statistics
  */
  getStats() {
  return {
  currentWebsite: this.currentWebsite,
  executionLog: this.executionLog,
  cacheHits: this.cacheHits,
  cacheMisses: this.cacheMisses,
  totalCost: this.totalCost,
  efficiency:
  this.cacheHits + this.cacheMisses > 0
  ? (this.cacheHits / (this.cacheHits + this.cacheMisses)) * 100
  : 0,
  };
  }
  }